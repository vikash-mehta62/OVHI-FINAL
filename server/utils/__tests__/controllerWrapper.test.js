const {\n  APIResponse,\n  controllerWrapper,\n  createController,\n  ParamExtractors,\n  ResponseTransformers,\n  InputValidators,\n  StatusCodes\n} = require('../controllerWrapper');\n\n// Mock the error handler\njest.mock('../../middleware/errorHandler', () => ({\n  handleControllerError: jest.fn((error, res, context) => {\n    res.status(500).json({\n      success: false,\n      error: {\n        message: error.message,\n        context\n      }\n    });\n  })\n}));\n\nconst { handleControllerError } = require('../../middleware/errorHandler');\n\ndescribe('Controller Wrapper Utilities', () => {\n  let mockReq, mockRes, mockNext;\n\n  beforeEach(() => {\n    mockReq = {\n      query: {},\n      params: {},\n      body: {},\n      user: { user_id: 123 }\n    };\n\n    mockRes = {\n      status: jest.fn().mockReturnThis(),\n      json: jest.fn().mockReturnThis()\n    };\n\n    mockNext = jest.fn();\n    \n    jest.clearAllMocks();\n  });\n\n  describe('APIResponse', () => {\n    it('should create success response', () => {\n      const response = APIResponse.success({ test: 'data' }, 'Success message');\n      \n      expect(response.success).toBe(true);\n      expect(response.data).toEqual({ test: 'data' });\n      expect(response.message).toBe('Success message');\n      expect(response.timestamp).toBeDefined();\n    });\n\n    it('should create error response', () => {\n      const response = APIResponse.error('Error message', { code: 'TEST_ERROR' });\n      \n      expect(response.success).toBe(false);\n      expect(response.message).toBe('Error message');\n      expect(response.error).toEqual({ code: 'TEST_ERROR' });\n    });\n\n    it('should create paginated response', () => {\n      const data = [{ id: 1 }, { id: 2 }];\n      const pagination = { page: 1, limit: 10, total: 2 };\n      const response = APIResponse.paginated(data, pagination, 'Data retrieved');\n      \n      expect(response.success).toBe(true);\n      expect(response.data).toEqual(data);\n      expect(response.message).toBe('Data retrieved');\n      expect(response.meta.pagination).toEqual(pagination);\n    });\n\n    it('should not include null data in response', () => {\n      const response = APIResponse.success(null, 'No data');\n      \n      expect(response.success).toBe(true);\n      expect(response.message).toBe('No data');\n      expect(response.hasOwnProperty('data')).toBe(false);\n    });\n  });\n\n  describe('controllerWrapper', () => {\n    it('should wrap service method successfully', async () => {\n      const mockService = jest.fn().mockResolvedValue({ test: 'result' });\n      const wrapper = controllerWrapper(mockService, {\n        successMessage: 'Operation successful',\n        successStatus: 200\n      });\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(mockService).toHaveBeenCalledWith({\n        userId: 123\n      });\n      expect(mockRes.status).toHaveBeenCalledWith(200);\n      expect(mockRes.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          success: true,\n          data: { test: 'result' },\n          message: 'Operation successful'\n        })\n      );\n    });\n\n    it('should handle paginated responses', async () => {\n      const mockService = jest.fn().mockResolvedValue({\n        data: [{ id: 1 }],\n        pagination: { page: 1, limit: 10, total: 1 }\n      });\n      const wrapper = controllerWrapper(mockService);\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(mockRes.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          success: true,\n          data: [{ id: 1 }],\n          meta: {\n            pagination: { page: 1, limit: 10, total: 1 }\n          }\n        })\n      );\n    });\n\n    it('should use custom parameter extractor', async () => {\n      const mockService = jest.fn().mockResolvedValue({ test: 'result' });\n      const extractParams = jest.fn().mockReturnValue({ customParam: 'value' });\n      const wrapper = controllerWrapper(mockService, { extractParams });\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(extractParams).toHaveBeenCalledWith(mockReq);\n      expect(mockService).toHaveBeenCalledWith({ customParam: 'value' });\n    });\n\n    it('should validate input when validator provided', async () => {\n      const mockService = jest.fn();\n      const validateInput = jest.fn().mockReturnValue({\n        isValid: false,\n        errors: ['Invalid input']\n      });\n      const wrapper = controllerWrapper(mockService, { validateInput });\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(validateInput).toHaveBeenCalled();\n      expect(mockService).not.toHaveBeenCalled();\n      expect(mockRes.status).toHaveBeenCalledWith(400);\n      expect(mockRes.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          success: false,\n          message: 'Validation failed',\n          error: ['Invalid input']\n        })\n      );\n    });\n\n    it('should transform response when transformer provided', async () => {\n      const mockService = jest.fn().mockResolvedValue({ original: 'data' });\n      const transformResponse = jest.fn().mockReturnValue({ transformed: 'data' });\n      const wrapper = controllerWrapper(mockService, { transformResponse });\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(transformResponse).toHaveBeenCalledWith({ original: 'data' });\n      expect(mockRes.json).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: { transformed: 'data' }\n        })\n      );\n    });\n\n    it('should handle service errors', async () => {\n      const mockService = jest.fn().mockRejectedValue(new Error('Service error'));\n      const wrapper = controllerWrapper(mockService);\n\n      await wrapper(mockReq, mockRes, mockNext);\n\n      expect(handleControllerError).toHaveBeenCalledWith(\n        expect.any(Error),\n        mockRes,\n        expect.any(String)\n      );\n    });\n  });\n\n  describe('createController', () => {\n    it('should create controller with wrapped methods', () => {\n      const mockService = {\n        getData: jest.fn().mockResolvedValue({ data: 'test' }),\n        updateData: jest.fn().mockResolvedValue({ updated: true })\n      };\n\n      const methodMappings = {\n        get: {\n          serviceMethod: 'getData',\n          options: { successMessage: 'Data retrieved' }\n        },\n        update: {\n          serviceMethod: 'updateData',\n          options: { successStatus: 201 }\n        }\n      };\n\n      const controller = createController(mockService, methodMappings);\n\n      expect(controller.get).toBeInstanceOf(Function);\n      expect(controller.update).toBeInstanceOf(Function);\n    });\n\n    it('should throw error for non-existent service method', () => {\n      const mockService = {};\n      const methodMappings = {\n        get: { serviceMethod: 'nonExistentMethod' }\n      };\n\n      expect(() => {\n        createController(mockService, methodMappings);\n      }).toThrow(\"Service method 'nonExistentMethod' not found\");\n    });\n  });\n\n  describe('ParamExtractors', () => {\n    describe('dashboardParams', () => {\n      it('should extract dashboard parameters', () => {\n        mockReq.query = { timeframe: '30d', compareWith: 'previous' };\n        \n        const params = ParamExtractors.dashboardParams(mockReq);\n        \n        expect(params).toEqual({\n          timeframe: '30d',\n          compareWith: 'previous',\n          userId: 123\n        });\n      });\n    });\n\n    describe('claimsParams', () => {\n      it('should extract and parse claims parameters', () => {\n        mockReq.query = {\n          page: '2',\n          limit: '20',\n          status: '1',\n          search: 'test'\n        };\n        \n        const params = ParamExtractors.claimsParams(mockReq);\n        \n        expect(params).toEqual({\n          page: 2,\n          limit: 20,\n          status: '1',\n          search: 'test',\n          priority: undefined,\n          dateFrom: undefined,\n          dateTo: undefined,\n          userId: 123\n        });\n      });\n\n      it('should use default values for missing parameters', () => {\n        const params = ParamExtractors.claimsParams(mockReq);\n        \n        expect(params.page).toBe(1);\n        expect(params.limit).toBe(10);\n      });\n    });\n\n    describe('claimUpdateParams', () => {\n      it('should extract claim update parameters', () => {\n        mockReq.params = { claimId: '123' };\n        mockReq.body = { status: 2, notes: 'Updated' };\n        \n        const params = ParamExtractors.claimUpdateParams(mockReq);\n        \n        expect(params).toEqual({\n          claimId: 123,\n          status: 2,\n          notes: 'Updated',\n          userId: 123\n        });\n      });\n    });\n  });\n\n  describe('InputValidators', () => {\n    describe('validateClaimUpdate', () => {\n      it('should validate valid claim update', () => {\n        const params = {\n          claimId: 123,\n          status: 2,\n          notes: 'Test'\n        };\n        \n        const result = InputValidators.validateClaimUpdate(params);\n        \n        expect(result.isValid).toBe(true);\n        expect(result.errors).toHaveLength(0);\n      });\n\n      it('should reject invalid claim ID', () => {\n        const params = {\n          claimId: 'invalid',\n          status: 2\n        };\n        \n        const result = InputValidators.validateClaimUpdate(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors).toContain('Valid claim ID is required');\n      });\n\n      it('should reject invalid status', () => {\n        const params = {\n          claimId: 123,\n          status: 99\n        };\n        \n        const result = InputValidators.validateClaimUpdate(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors).toContain('Invalid status value');\n      });\n    });\n\n    describe('validatePagination', () => {\n      it('should validate valid pagination', () => {\n        const params = { page: 1, limit: 10 };\n        \n        const result = InputValidators.validatePagination(params);\n        \n        expect(result.isValid).toBe(true);\n      });\n\n      it('should reject invalid page', () => {\n        const params = { page: 0 };\n        \n        const result = InputValidators.validatePagination(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors).toContain('Page must be a positive integer');\n      });\n\n      it('should reject invalid limit', () => {\n        const params = { limit: 200 };\n        \n        const result = InputValidators.validatePagination(params);\n        \n        expect(result.isValid).toBe(false);\n        expect(result.errors).toContain('Limit must be between 1 and 100');\n      });\n    });\n  });\n\n  describe('ResponseTransformers', () => {\n    describe('dashboardTransformer', () => {\n      it('should transform dashboard data', () => {\n        const data = {\n          summary: {\n            totalBilled: 1000,\n            totalCollected: 800,\n            totalAR: 200\n          },\n          other: 'data'\n        };\n        \n        const result = ResponseTransformers.dashboardTransformer(data);\n        \n        expect(result).toEqual({\n          summary: {\n            totalBilled: 1000,\n            totalCollected: 800,\n            totalAR: 200\n          },\n          other: 'data'\n        });\n      });\n    });\n\n    describe('claimsTransformer', () => {\n      it('should transform claims data', () => {\n        const data = {\n          claims: [{ id: 1 }],\n          filters: { status: 'all' },\n          pagination: { page: 1 }\n        };\n        \n        const result = ResponseTransformers.claimsTransformer(data);\n        \n        expect(result).toEqual({\n          claims: [{ id: 1 }],\n          filters: { status: 'all' }\n        });\n      });\n    });\n  });\n\n  describe('StatusCodes', () => {\n    it('should have correct HTTP status codes', () => {\n      expect(StatusCodes.OK).toBe(200);\n      expect(StatusCodes.CREATED).toBe(201);\n      expect(StatusCodes.BAD_REQUEST).toBe(400);\n      expect(StatusCodes.NOT_FOUND).toBe(404);\n      expect(StatusCodes.INTERNAL_SERVER_ERROR).toBe(500);\n    });\n  });\n});"